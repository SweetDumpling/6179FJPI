## 底盘算法

### 1 例程中的算法

看PacGoat的DriveForward类。

**思考：** 这个类的作用？它实现了什么动作？Kp的意义？这个类在运动方向上有什么不足？

**练习：** 改进这个类的不足，并用这个算法来通过Gyro控制机器人转角。

**思考2：** 你有什么其它更好的控制算法？实现出来尝试一下。

这个类是用来进行前进距离校准的。**Kp是最后开始减速的位置到最终位置距离的倒数。减速是为了防止惯性导致实际距离偏大。**

不过这个类没法做到后退以及运动中方向偏转的矫正。尝试实现这些吧！

### 2 使用PIDController类

 **警告: 此部分未经实验，可能有误。** 

PIDController类是官方提供的一个PID控制类。使用它可以对机器人或其上结构件的移动和转向进行校准。PID算法是目前工业上普遍使用的算法，比起前面介绍的算法，有更高的准确度和稳定性。设置好参数及目标位置后，再输入当前位置，PIDController可以自动算出应该设置的速度值。

先看[PIDController的API](http://first.wpi.edu/FRC/roborio/release/docs/java/edu/wpi/first/wpilibj/PIDController.html)。下面这个构造方法应该是常用的了，API里的Kf是前馈控制(feed forward)用的，目前应该用不到:

```
PIDController(double Kp, double Ki, double Kd, PIDSource source, PIDOutput output, double period)
Allocate a PID object with the given constants for P, I, D and period.
```
根据这个构造方法，我们先来补充一点PID相关知识。因为基础不足的原因，这里不会讲解PID究竟是如何运作的，只是介绍一下参数中每个值是什么意思。

 `double Kp` 是PID中P部分的权重，即误差调节的权重。当前误差较大时，P部分会输出较高的值。如果这个权重Kp过小，校准会过慢甚至失效。如果过大，会出现过校，导致结构抽搐(不断摆动)。其实例程中的算法就是PID的P部分。

 `double Ki` 是PID中I部分的权重，即积分调节的权重。如果当前误差持续无法达到0，也就是结构很长时间都无法达到目标点的话，I部分的输出值会持续增大。

 `double Kd` 是PID中D部分的权重，即微分调节权重。它通过一段时间(period秒)前的误差值和当前误差值，预测下一个(period秒后的)误差值。再根据预测的误差值进行误差调节，将其结果作为此部分的输出。

最后PID输出的结果是这三部分输出的总和。

 `double period` 是每一步PID计算的间隔时间(单位为秒)，可以理解为输出速度的刷新率。注意均衡效果和运算速度。

那么 `PIDSource source` 和 `PIDSource output` 是什么呢？这部分理解起来可能会稍有难度。注意看它们的类型，这两个类型其实是两个interface，需要被继承。让我们看看它们的API: [PIDOutput](http://first.wpi.edu/FRC/roborio/release/docs/java/edu/wpi/first/wpilibj/PIDOutput.html)，[PIDSource](http://first.wpi.edu/FRC/roborio/release/docs/java/edu/wpi/first/wpilibj/PIDSource.html)。

PIDOutput有一个 `pidWrite()` 方法，PIDSource有一个 `pidSource()` 方法(注意这两个方法不需要自己调用)。继承它们的类必然实现这两个抽象方法。再看API里提及的它们所有的子类，是不是有点明白了？你只要把继承于PIDSource和PIDOutput的类作为参数传进去就可以直接用了。比如你可以这样:
```Java
//这是一个通过Encoder校准前进距离的程序
Encoder encoder = new Encoder();
SpeedController motor = new Talon(0);

PIDController controller = new PIDController(0.2, 0.2, 0.2, encoder, motor, 0.05);
```
是不是很简单？构造好了，可以开始用了。首先设置一些东西。

```Java
controller.setAbsoluteTolerance(0.1);
//设置目标点误差允许绝对范围，此处为±0.1cm

//controller.setPercentTolerance(1.0);
//设置目标点误差允许百分比范围，此处为1％

controller.setSetpoint(100.0);
//设置目标点的值，此处为100cm
//此处数据的单位应与PIDSource的输出单位相同

controller.setOutputRange(-0.5, 0.5);
//设置PID输出范围，在这里是马达速度值范围

//controller.setInputRange(-200.0, 200.0);
//设置PID输入范围(Encoder距离校准一般不需设置)
//误差如果使用百分比形式，必须设置
```
开始使用PIDController:
```Java
controller.enable();
//启动PIDController

while(!onTarget())
    Timer.delay(0.02);
//等待当前位置到达误差允许范围内
//此处是一个示意，onTarget()应当在Command的isFinished()中调用

controller.disable();
//关闭PIDController

//controller.reset();
//关闭PIDController并重置数据，为下次使用准备

controller.free();
//释放资源，应该在最后一次使用后调用
```
参数的调整方法目前还没有经验，希望能有人帮助补充。

你可能已经注意到了API里还有两个类: PIDSubsystem和PIDCommand。不过它们的API做得很差，使用时可能会引起歧义，并且会影响程序编写的灵活性。最好不要使用。